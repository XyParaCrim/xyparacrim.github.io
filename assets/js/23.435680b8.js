(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{504:function(s,t,a){"use strict";a.r(t);var e=a(4),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"redis持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[s._v("#")]),s._v(" Redis持久化")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[s._v("😟😟😟")]),s._v(" "),a("p",[s._v("Redis支持两种持久化模式快照和AOF")])]),s._v(" "),a("h2",{attrs:{id:"回顾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回顾"}},[s._v("#")]),s._v(" 回顾")]),s._v(" "),a("ul",[a("li",[s._v("快照：全量备份，以内存数据的二进制序列化形式，在储存上非常紧凑")]),s._v(" "),a("li",[s._v("AOF：增量备份，以内存数据的指令记录文本形式。长期运行AOF日志会变得庞大，若数据库重启需要加载AOF日志进行重放时，会花费非常长的时间，因此需要定期对AOF进行瘦身")])]),s._v(" "),a("h2",{attrs:{id:"快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照"}},[s._v("#")]),s._v(" 快照")]),s._v(" "),a("p",[s._v("Redis使用的是多进程与Copy on Write机制实现快照持久化")]),s._v(" "),a("h3",{attrs:{id:"fork"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fork"}},[s._v("#")]),s._v(" fork")]),s._v(" "),a("blockquote",[a("p",[s._v("Nginx和Nodejs也是使用fork进行多进程处理")])]),s._v(" "),a("p",[s._v("Redis将数据分为4KB大小的页，当父进程需要写时，会对复制页进行修改，子进程会将那一瞬间的页写入磁盘中")]),s._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("See More")]),s._v(" "),a("p",[s._v("子进程刚刚创建时，它与父进程共享内存里面的代码段和数据段。在进程分离的一瞬间，内存的增长几乎没有。")])]),s._v(" "),a("h2",{attrs:{id:"aof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[s._v("#")]),s._v(" AOF")]),s._v(" "),a("p",[s._v("AOF日志储存Redis执行对内存修改的指令，通过重放恢复数据。")]),s._v(" "),a("details",{staticClass:"custom-block details"},[a("summary",[s._v("See More")]),s._v(" "),a("p",[s._v("Redis时先执行指令再将指令存入磁盘")])]),s._v(" "),a("h3",{attrs:{id:"aof瘦身"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof瘦身"}},[s._v("#")]),s._v(" AOF瘦身")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("Redis提供`bgrewriteaof`指令进行瘦身，其原理是创建一个子进程对内存进行遍历，转换成一系列Reis的操作指令，\n序列化到一个新的AOF日志文件。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，\n追加完毕后就立即代替旧的AOF日志文件，瘦身完毕\n")])])]),a("h3",{attrs:{id:"fsync"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fsync"}},[s._v("#")]),s._v(" fsync")]),s._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",[s._v("Elasticseach类比")])]),s._v(" "),a("ol",[a("li",[s._v("时间写的过程：AOF日志文件 -> 内存缓存 -> 异步刷回磁盘")]),s._v(" "),a("li",[a("code",[s._v("fsync")]),s._v("函数会实时将缓存刷回磁盘")]),s._v(" "),a("li",[s._v("Redis每隔1s执行一次"),a("code",[s._v("fsync")])]),s._v(" "),a("li",[s._v("Elasticsearch每隔5s执行一次"),a("code",[s._v("fsync")]),s._v("（translog）")])]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[s._v("一般从节点进行持久化，主节点不进行持久化")])]),s._v(" "),a("h2",{attrs:{id:"redis4-0混合持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis4-0混合持久化"}},[s._v("#")]),s._v(" Redis4.0混合持久化")]),s._v(" "),a("p",[s._v("先加载rdb文件数据，再重放增量AOF日志，从而代替AOF全量文件重放")])])}),[],!1,null,null,null);t.default=r.exports}}]);