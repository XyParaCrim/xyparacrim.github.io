(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{503:function(e,t,s){"use strict";s.r(t);var o=s(4),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis线程io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis线程io模型"}},[e._v("#")]),e._v(" Redis线程IO模型")]),e._v(" "),s("blockquote",[s("p",[e._v("😵😵😵")]),e._v(" "),s("p",[e._v("Redis线程IO模型使用的是"),s("strong",[e._v("多路复用")])])]),e._v(" "),s("h2",{attrs:{id:"redis中多路复用-nio"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis中多路复用-nio"}},[e._v("#")]),e._v(" Redis中多路复用（NIO）")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("阻塞IO")]),e._v("是因为系统提供的接口为阻塞的\n"),s("strong",[e._v("非阻塞IO")]),e._v("是因为系统提供"),s("code",[e._v("Non_Blocking")]),e._v("的选项，每次调用接口时，进行最大程度的可读/可写")])]),e._v(" "),s("ul",[s("li",[e._v("当线程没有事件时，进入阻塞状态")]),e._v(" "),s("li",[e._v("当有事件时，运行线程，将事件交给对应线程继续处理（单线程只能等待事件处理完，再继续轮询事件）")])]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[e._v("现代操作系统已经不再使用"),s("code",[e._v("select")]),e._v("的系统方法啦，因为事件描述符对于性能有影响，而改用"),s("code",[e._v("epoll")]),e._v("（Linux）和"),s("code",[e._v("kqueue")]),e._v("（FreeBSD和Macosx）")])]),e._v(" "),s("h2",{attrs:{id:"定时任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定时任务"}},[e._v("#")]),e._v(" 定时任务")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("Redis定时任务会记录在一个最小堆中，在每个循环周期中，Redis会对堆中已经到时的任务进行处理。当处理完后，获取堆顶的执行时间，用于\n`select`的`timeout`参数\n")])])]),s("blockquote",[s("p",[e._v("Nginx、NodeJs和Redis的事件处理的原理相似")])])])}),[],!1,null,null,null);t.default=a.exports}}]);